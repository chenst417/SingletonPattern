定义：
	一个类定义到另一个类的内部，这样的类就叫做内部类。
特点：
	a:静态内部类和成员内部类可以被外部访问(private除外)，
	匿名内部类和局部内部类不能被外部访问。
分类：重要性依次递减。
	静态内部类、
		定义：定义在一个类的内部，只不过前面用static修饰符就行修饰。
		特点：
			a:不能访问外部类的非static成员变量或者成员方法。

	匿名内部类、


	成员内部类、
		定义：定义在一个类的内部，类似于定义的成员变量或者成员方法一样。
		特点：
			a:成员内部类可以随意访问外部类的所有属性和所有方法(包括private的属性、方法和静态成员)，
			b:如果内部类出现和外部类相同的成员变量和方法时，默认调用的是内部类的成员变量和方法，
		  	如果想访问外部类的成员变量和方法，
		  		必须 ：外部类.this.成员变量
		  			   外部类.this.成员方法
			c:外部类想访问内部类的成员变量和方法，必须先创建内部类的对象，然后通过内部类的对象进行调用。
	局部内部类，
		定义：定义在一个类的方法或者作用域里面的类
		特点：
			a:它和成员内部类的区别在于局部内部类的访问仅限于方法内部或者该作用域内。
			b:局部内部类就像方法里面的一个局部变量一样，
			是不能有public、protected、private以及static修饰符的。
应用场景：
	a:每个内部类都可以独立继承一个接口的实现，所有无论外部类是否继承了某个接口的实现，
		对内部类都没有影响，内部类为多继承提供了很好的解决方案
	b:方便将存在一定逻辑的类组织在一起，同时对外界进行隐藏
	c:方便编写事件驱动程序
	d:方便编写线程代码

	1：为什么成员内部类可以无条件访问外部类的成员？
		分析：
			编译器默认会给成员内部类添加外部类对象地址的引用，
			编译器默认会构造一个成员内部类的含参构造函数，参数默认是外部类对象地址的引用
			因此成员内部类可以随意访问外部类的所有属性、方法。
			因此成员内部类依赖外部类存在，没有实例化外部类，就没有办法完成成员内部类的实例化。
	2：为什么局部内部类和匿名内部类只能访问局部final变量？
		分析：
			根本原因是作用域中变量的生命周期导致的，
			局部内部类、匿名内部类和外部类是处于同一个级别的，不会因为定义在方法内，随着方法的的销毁而销毁。
			当外部类方法执行结束的时候，变量就会被销毁。但是内部类还可能存在，没有被GC回收，
				这样就产生内部类调用一个不存在的变量的情况。为了解决这个问题，就将局部变量进行复制保存一份，
				作为内部类的成员变量，这样当局部变量死亡后，内部类依然可以访问它，实际上访问的是它的“copy”，
				相当于延长了局部变量的生命周期。
			但是有可能出现外部类方法修改局部变量的值、或者是内部类修改局部变量的值，这样就导致局部变量的值不一致的问题。
				为了解决这个问题，所有在局部变量前通过final修饰，不允许局部变量被修改，这也是一种折中的办法。
	3：静态内部类有特殊的地方吗？
		分析：
			静态内部类不依赖于外部类，所有不需要创建外部类对象就可以实例化静态内部类，所有静态内部类不存储外部类对象地址的引用。

	4：梳理内部类的执行逻辑，并画出时序图。
		内部类和外部类一样，当外部类被实例化的时候，内部类同时也进行实例化，
		但是内部类的属性和方法才进行初始化。